<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Architecture on Ian Nelson</title>
    <link>https://blog.iannelson.uk/tags/architecture/</link>
    <description>Recent content in Architecture on Ian Nelson</description>
    <generator>Hugo -- 0.146.6</generator>
    <language>en</language>
    <lastBuildDate>Sun, 04 May 2025 20:46:51 +0100</lastBuildDate>
    <atom:link href="https://blog.iannelson.uk/tags/architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Enterprise Integration Anti-Patterns #2 – Shared Assemblies</title>
      <link>https://blog.iannelson.uk/enterprise-integration-anti-patterns-2-shared-assemblies/</link>
      <pubDate>Wed, 01 Dec 2010 10:12:00 +0000</pubDate>
      <guid>https://blog.iannelson.uk/enterprise-integration-anti-patterns-2-shared-assemblies/</guid>
      <description>&lt;p&gt;Having slain the beast that is &lt;a href=&#34;https://blog.iannelson.uk/enterprise-integration-anti-patterns-1-the-shared-database/&#34;&gt;Shared Database&lt;/a&gt;, the next dragon to appear on my Enterprise Integration horizon is Shared Assemblies. That is, the suggestion that Application A can leverage the functionality of Application B by simply adding references to B’s DLLs. After all, this potential for reuse is why we put our code in reusable assemblies in the first place, isn’t it..?!&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://blogstouks01.z33.web.core.windows.net/2023/08/iStock_000012931845XSmall_3.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;Well, no. Actually we usually break our application apart into assemblies to create a maintainable and testable architecture. An assembly is a coarse-grained unit of encapsulated functionality in that architecture; the fact that it is the smallest deployable unit in the .NET world is not necessarily an indication that we intend or desire our assemblies to be shared with other applications.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Having slain the beast that is <a href="https://blog.iannelson.uk/enterprise-integration-anti-patterns-1-the-shared-database/">Shared Database</a>, the next dragon to appear on my Enterprise Integration horizon is Shared Assemblies. That is, the suggestion that Application A can leverage the functionality of Application B by simply adding references to B’s DLLs. After all, this potential for reuse is why we put our code in reusable assemblies in the first place, isn’t it..?!</p>
<p><img loading="lazy" src="https://blogstouks01.z33.web.core.windows.net/2023/08/iStock_000012931845XSmall_3.jpg"></p>
<p>Well, no. Actually we usually break our application apart into assemblies to create a maintainable and testable architecture. An assembly is a coarse-grained unit of encapsulated functionality in that architecture; the fact that it is the smallest deployable unit in the .NET world is not necessarily an indication that we intend or desire our assemblies to be shared with other applications.</p>
<p>In my experience, sharing assemblies works only when they have been developed with this intention in mind. It’s feasible to share DLLs that contain discrete chunks of easily-encapsulated functionality that have no need for external dependencies (hasn’t every dev shop got a “common” or “utilities” library hanging around somewhere?!) but it’s quite another matter to start taking a wholesale dependency on the guts of another application.</p>
<p>So, before you try the shared assemblies approach to enterprise integration, here are a few things to consider:</p>
<h2 id="is-it-even-possible">Is It Even Possible?</h2>
<p>Firstly, this approach makes the assumption that the application to be referenced has been developed such that all the logic to be invoked exists in the assemblies. If the application wasn’t originally developed with the intention of being shared in this way, there’s every possibility that some pertinent logic has instead been located in the front-end (e.g. the <a href="http://en.wikipedia.org/wiki/Magic_pushbutton">“Magic Pushbutton”</a> anti-pattern that was so prevalent in ASP.NET Web Forms development), or even client-side scripts.</p>
<h2 id="love-me-love-my-dependencies">Love Me, Love My Dependencies…</h2>
<p>All applications have dependencies of one kind or another. If you’re lucky, this will just be the .NET Framework, and if you’re especially lucky it will be the same version that is used by the consuming application.</p>
<p>More likely, the application being referenced will depend on a whole bunch of third-party DLLs, and now they’ve suddenly become your dependencies, too! If your dev shop is anything like the places I’ve worked, each application will depend on various different versions of the NHibernate and Castle stacks and their associated dependencies. Good luck managing all those references while retaining your sanity.</p>
<h2 id="applications-are-more-than-just-dlls">Applications are more than just DLLs</h2>
<p>The average enterprise application is more than just a bunch of assemblies that can be referenced independently. They also tend to rely on configuration settings, external resources (e.g. databases), and a whole bunch of stuff triggered at application start-up time such as the configuration of an IoC container, logging, ORM, etc. The handling of authentication and authorization might also need rethinking before assembly sharing becomes a viable option.</p>
<h2 id="maintaining-the-combined-suite-of-applications">Maintaining the Combined Suite of Applications</h2>
<p>As I said in <a href="https://blog.iannelson.uk/enterprise-integration-anti-patterns-1-the-shared-database/">my previous post on this topic</a>, maintainability is a particular bugbear of mine as a developer, and sharing assemblies across multiple applications doesn’t help matters one iota.</p>
<p>Unless you work with unbearably large solutions containing every project in your suite of applications, it’s difficult to know the wider impact that modifications will have, and to avoid making breaking changes. For sure, it’s possible to run automated builds of all applications when shared code is changed (I blogged about one method of achieving this with the first version of Team Foundation Server some years ago before I came to the conclusion that this is A Bad Idea) but by then the hard work has been done, the code checked in and the damage done.</p>
<p>Arguably, sharing assemblies puts developers in an even stickier situation than sharing databases – at least with that anti-pattern the entanglement is limited to one particular layer of the architecture which can be largely ignored much of the time. But when assemblies are shared, the developers must always be considering whether their apparently innocent modifications will have an impact on some other application. Meaningful refactoring becomes impossible, and the software eventually falls into disrepair.</p>
<p><img loading="lazy" src="https://blogstouks01.z33.web.core.windows.net/2023/08/iStock_000004248715XSmall_3.jpg"></p>
<h2 id="in-conclusion">In Conclusion…</h2>
<p>When all is said and done, there are only two realistic patterns for sharing functionality between enterprise applications – remote procedure invocation and messaging. Both serve to decouple the applications, and both are easy to achieve with popular technologies on the .NET stack such as <a href="http://msdn.microsoft.com/en-us/netframework/aa663324.aspx">WCF</a>, <a href="http://trac.caffeine-it.com/openrasta">OpenRasta</a> and <a href="http://masstransit-project.com/">MassTransit</a>.</p>
<p>There’s an abundance of resources out there detailing how to create effective service-oriented architectures, the obvious canonical reference tome being Hohpe and Woolf’s <a href="http://amzn.to/gkOq3C"><em>Enterprise Integration Patterns</em></a>. I also highly recommend Michael Nygard’s <a href="http://amzn.to/h9NVFK"><em>Release It!</em></a> for an entertaining overview of some of the problems that can be encountered when you start taking dependencies on remote services, and useful patterns for ensuring your application remains responsive at all times.</p>
<p>My preferred technology stack for application integration remains WCF, and in a future blog post I’ll outline some tips I’ve learned through trial and error for developing and consuming effective and maintainable WCF services.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Enterprise Integration Anti-Patterns #1 – The Shared Database</title>
      <link>https://blog.iannelson.uk/enterprise-integration-anti-patterns-1-the-shared-database/</link>
      <pubDate>Mon, 08 Nov 2010 05:11:00 +0000</pubDate>
      <guid>https://blog.iannelson.uk/enterprise-integration-anti-patterns-1-the-shared-database/</guid>
      <description>&lt;p&gt;So, I was in the office at a client site, walking back to my desk after grabbing a quick coffee, when a developer on a sister product to my current project grabbed me and asked (I paraphrase somewhat):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Hey, Ian – [my app] needs to retrieve [small piece of data] from [your app], so I’ve stuck a stored proc in [your database], OK?”&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I felt quite violated. My poor app, what had it done to deserve this despicable treatment?&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>So, I was in the office at a client site, walking back to my desk after grabbing a quick coffee, when a developer on a sister product to my current project grabbed me and asked (I paraphrase somewhat):</p>
<blockquote>
<p>“Hey, Ian – [my app] needs to retrieve [small piece of data] from [your app], so I’ve stuck a stored proc in [your database], OK?”</p></blockquote>
<p>I felt quite violated. My poor app, what had it done to deserve this despicable treatment?</p>
<p>Before I start my rant about the downsides of directly accessing application databases in this way, let me first try to enumerate the benefits of such an approach. I can think of three:</p>
<ol>
<li>It’s a quick solution to develop (at least initially).</li>
<li>The technical concepts involved are well understood by the vast majority of developers and other team members.</li>
<li>The functionality is encapsulated in one place, i.e. the stored proc, which is at least preferable to allowing the execution of ad-hoc SQL.</li>
</ol>
<p>But despite this being seen as a quick-win, I think allowing application databases to be shared in this way is almost always a bad idea in the medium to long term.</p>
<p>As a developer, one of my primary goals is to create systems that are easy to maintain and enhance, in anticipation of the inevitable future change requests that will put food on my children’s plates. As well as making life easier for yourself, this approach is also common courtesy to the programmers that maintain the system after you’ve left. As the saying goes, “always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live” – I think that’s good advice to heed for all developers who have an interest in building their reputation in our small and incestuous industry.</p>
<p>When we begin down the slippery slope of forcing a single database to serve the needs of multiple disparate consuming systems, we make a rod for our own backs. Any planned changes to the database to meet new requirements in the primary application need to consider the needs of the parasitic applications that care little for your ability to respond to change as long as they continue working. In our particular scenario, it’s worth highlighting that “my” application is using NHibernate as an ORM layer, so until this invasion we have been able to perform database schema refactorings with relative impunity. No longer – now we have to consider and potentially maintain someone else’s stored procedure when making changes.</p>
<p>Sure, at the start it’s “just a stored proc”, and the maintenance overhead is relatively low. But like the proverbial broken window, allowing that first chink in your carefully-crafted layered application architecture sets a dangerous precedent. If it goes unchecked, it may be seen as a valid pattern to be emulated by future developers, until the database schema ossifies and becomes almost impossible to change as it struggles to meet the requirements of multiple consuming applications.</p>
<p>If you think I’m scaremongering or labouring a point here I would urge you to spend some time hanging out on the NHibernate and Fluent NHibernate mailing lists. It won’t be long before you see messages that describe complex and intractable mapping problems and mention the caveat “I’m not allowed to change the database”.</p>
<p>Aside from the maintainability issue (which is my major gripe), the end result of this quick-and-dirty approach also leads to a poorer-quality solution which may struggle to meet nonfunctional requirements. Direct database access from external applications is a crude, low-level solution to a common problem. All the hard work done in creating a layered architecture with DAOs, business logic layer etcetera is swept aside by some other cowboy app which says “screw all that, gimme the data”. Any considerations that may have been given to concerns such as caching and application-level security go out of the window. The potential for locks and even deadlocks on the shared database is increased.</p>
<p>If you have the smallest shred of dignity and self-respect on behalf of your application, then please – don’t let its nether regions be exposed to all and sundry.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
